import * as z from './base';
import { ZodUndefined } from './undefined';
import { ZodNull } from './null';
import { ZodUnion } from './union';
import { objectUtil } from '../helpers/objectUtil';
export interface ZodObjectDef<T extends z.ZodRawShape = z.ZodRawShape, Params extends ZodObjectParams = ZodObjectParams> extends z.ZodTypeDef {
    t: z.ZodTypes.object;
    shape: T;
    params: Params;
}
interface ZodObjectParams {
    strict: boolean;
}
declare type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true ? objectUtil.ObjectType<T> : objectUtil.Flatten<objectUtil.ObjectType<T> & {
    [k: string]: any;
}>;
export declare class ZodObject<T extends z.ZodRawShape, Params extends ZodObjectParams = {
    strict: true;
}> extends z.ZodType<ZodObjectType<T, Params>, // { [k in keyof T]: T[k]['_type'] },
ZodObjectDef<T, Params>> {
    readonly _shape: T;
    private readonly _params;
    readonly shape: T;
    readonly params: Params;
    toJSON: () => {
        t: z.ZodTypes.object;
        shape: {
            [x: string]: any;
        }[];
    };
    nonstrict: () => ZodObject<T, objectUtil.Flatten<{ [k in Exclude<keyof Params, "strict">]: Params[k]; } & {
        strict: false;
    }>>;
    optional: () => ZodUnion<[this, ZodUndefined]>;
    nullable: () => ZodUnion<[this, ZodNull]>;
    augment: <Augmentation extends z.ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k in keyof Augmentation]: Augmentation[k]; }, Params>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(other: ZodObject<MergeShape, MergeParams>) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>>;
    pick: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k in keyof Mask]: k extends keyof T ? T[k] : never; }, Params>;
    omit: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k in keyof T]: k extends keyof Mask ? never : T[k]; }, Params>;
    partial: () => ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]>; }, Params>;
    deepPartial: () => ZodObject<{ [k in keyof T]: {
        object: T[k] extends ZodObject<infer Shape, infer Params_1> ? ZodUnion<[ZodObject<{ [k in keyof Shape]: {
            object: Shape[k] extends ZodObject<infer Shape, infer Params_1> ? ZodUnion<[ZodObject<any, Params_1>, ZodUndefined]> : never;
            rest: ZodUnion<[Shape[k], ZodUndefined]>;
        }[Shape[k] extends ZodObject<any, {
            strict: true;
        }> ? "object" : "rest"]; }, Params_1>, ZodUndefined]> : never;
        rest: ZodUnion<[T[k], ZodUndefined]>;
    }[T[k] extends ZodObject<any, {
        strict: true;
    }> ? "object" : "rest"]; }, {
        strict: true;
    }>;
    static create: <T_1 extends z.ZodRawShape>(shape: T_1) => ZodObject<T_1, {
        strict: true;
    }>;
}
export {};
