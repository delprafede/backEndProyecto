"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var z = __importStar(require("./types/base"));
var ZodError_1 = require("./ZodError");
var util_1 = require("./helpers/util");
exports.ZodParser = function (schemaDef) { return function (obj, params) {
    if (params === void 0) { params = { seen: [] }; }
    var def = schemaDef;
    // const { seen } = params;
    // const y:ZodObject<any> = "asdf" as any;
    // console.log(`visit ${schemaDef.t}: ${typeof obj} - ${obj.name || ''}`);
    // if (!['number', 'string', 'boolean', 'undefined'].includes(typeof obj)) {
    var schemaSeen = params.seen.find(function (x) { return x.schema === schemaDef; });
    if (schemaSeen) {
        if (schemaSeen.objects.indexOf(obj) !== -1) {
            // console.log(`seen ${typeof obj} before: ${obj.name}`);
            return obj;
        }
        else {
            schemaSeen.objects.push(obj);
        }
    }
    else {
        params.seen.push({ schema: schemaDef, objects: [obj] });
    }
    // }
    switch (def.t) {
        case z.ZodTypes.string:
            if (typeof obj !== 'string')
                throw ZodError_1.ZodError.fromString("Non-string type: " + typeof obj);
            return obj;
        case z.ZodTypes.number:
            if (typeof obj !== 'number')
                throw ZodError_1.ZodError.fromString("Non-number type: " + typeof obj);
            if (Number.isNaN(obj)) {
                throw ZodError_1.ZodError.fromString("Non-number type: NaN");
            }
            return obj;
        case z.ZodTypes.boolean:
            if (typeof obj !== 'boolean')
                throw ZodError_1.ZodError.fromString("Non-boolean type: " + typeof obj);
            return obj;
        case z.ZodTypes.undefined:
            if (obj !== undefined)
                throw ZodError_1.ZodError.fromString("Non-undefined type:Found: " + typeof obj);
            return undefined;
        case z.ZodTypes.null:
            if (obj !== null)
                throw ZodError_1.ZodError.fromString("Non-null type: " + typeof obj);
            return null;
        case z.ZodTypes.array:
            if (!Array.isArray(obj))
                throw ZodError_1.ZodError.fromString("Non-array type: " + typeof obj);
            var arrayError_1 = ZodError_1.ZodError.create([]);
            if (def.nonempty === true && obj.length === 0) {
                throw ZodError_1.ZodError.fromString('Array cannot be empty');
            }
            var parsedArray = obj.map(function (item, i) {
                try {
                    var parsedItem = def.type.parse(item, params);
                    return parsedItem;
                }
                catch (err) {
                    arrayError_1.mergeChild(i, err);
                }
            });
            if (!arrayError_1.empty) {
                // throw ZodError.fromString(arrayErrors.join('\n\n'));
                throw arrayError_1;
            }
            return parsedArray;
        case z.ZodTypes.object:
            if (typeof obj !== 'object')
                throw ZodError_1.ZodError.fromString("Non-object type: " + typeof obj);
            if (Array.isArray(obj))
                throw ZodError_1.ZodError.fromString("Non-object type: array");
            var shape = def.shape;
            if (def.params.strict) {
                var shapeKeys_1 = Object.keys(def.shape);
                var objKeys = Object.keys(obj);
                var extraKeys = objKeys.filter(function (k) { return shapeKeys_1.indexOf(k) === -1; });
                if (extraKeys.length) {
                    // console.log(def);
                    throw ZodError_1.ZodError.fromString("Unexpected key(s) in object: " + extraKeys.map(function (k) { return "'" + k + "'"; }).join(', '));
                }
            }
            var parsedObject = {};
            var objectError = ZodError_1.ZodError.create([]);
            for (var key in shape) {
                try {
                    var parsedEntry = def.shape[key].parse(obj[key], params);
                    parsedObject[key] = parsedEntry;
                }
                catch (err) {
                    objectError.mergeChild(key, err);
                }
            }
            if (!objectError.empty) {
                throw objectError; //ZodError.fromString(objectErrors.join('\n'));
            }
            return parsedObject;
        case z.ZodTypes.union:
            for (var _i = 0, _a = def.options; _i < _a.length; _i++) {
                var option = _a[_i];
                try {
                    return option.parse(obj, params);
                    // return obj;
                }
                catch (err) { }
            }
            throw ZodError_1.ZodError.fromString("Type mismatch in union.\nReceived: " + JSON.stringify(obj, null, 2) + "\n\nExpected: " + def.options
                .map(function (x) { return x._def.t; })
                .join(' OR '));
        case z.ZodTypes.intersection:
            var errors = [];
            try {
                def.left.parse(obj, params);
            }
            catch (err) {
                errors.push("Left side of intersection: " + err.message);
            }
            try {
                def.right.parse(obj, params);
            }
            catch (err) {
                errors.push("Right side of intersection: " + err.message);
            }
            if (!errors.length) {
                return obj;
            }
            throw ZodError_1.ZodError.fromString(errors.join('\n'));
        case z.ZodTypes.tuple:
            if (!Array.isArray(obj)) {
                // tupleError.addError('','Non-array type detected; invalid tuple.')
                throw ZodError_1.ZodError.fromString('Non-array type detected; invalid tuple.');
            }
            if (def.items.length !== obj.length) {
                // tupleError.addError('',`Incorrect number of elements in tuple: expected ${def.items.length}, got ${obj.length}`)
                throw ZodError_1.ZodError.fromString("Incorrect number of elements in tuple: expected " + def.items.length + ", got " + obj.length);
            }
            var tupleError = ZodError_1.ZodError.create([]);
            var parsedTuple = [];
            for (var index in obj) {
                var item = obj[index];
                var itemParser = def.items[index];
                try {
                    parsedTuple.push(itemParser.parse(item, params));
                }
                catch (err) {
                    tupleError.mergeChild(index, err);
                }
            }
            if (!tupleError.empty) {
                throw tupleError;
            }
            return parsedTuple;
        case z.ZodTypes.lazy:
            var lazySchema = def.getter();
            return lazySchema.parse(obj, params);
        // return obj;
        case z.ZodTypes.literal:
            // const literalValue = def.value;
            // if (typeof literalValue === 'object' && obj !== null) throw ZodError.fromString(`Can't process non-primitive literals.`);
            // if (['string','']typeof obj === 'object') throw ZodError.fromString(`Invalid type: ${object}.`);
            if (obj === def.value)
                return obj;
            throw ZodError_1.ZodError.fromString(obj + " !== " + def.value);
        case z.ZodTypes.enum:
            if (def.values.indexOf(obj) === -1) {
                throw ZodError_1.ZodError.fromString("\"" + obj + "\" does not match any value in enum");
            }
            return obj;
        // case z.ZodTypes.function:
        //   return obj;
        case z.ZodTypes.record:
            if (typeof obj !== 'object')
                throw ZodError_1.ZodError.fromString("Non-object type: " + typeof obj);
            if (Array.isArray(obj))
                throw ZodError_1.ZodError.fromString("Non-object type: array");
            var parsedRecord = {};
            var recordError = new ZodError_1.ZodError();
            for (var key in obj) {
                try {
                    parsedRecord[key] = def.valueType.parse(obj[key]);
                }
                catch (err) {
                    recordError.mergeChild(key, err);
                }
            }
            if (!recordError.empty)
                throw recordError;
            return parsedRecord;
        case z.ZodTypes.date:
            if (obj instanceof Date) {
                if (!isNaN(obj.getTime())) {
                    return obj;
                }
                else {
                    throw ZodError_1.ZodError.fromString("Invalid date.");
                }
            }
            throw ZodError_1.ZodError.fromString("Non-Date type: " + obj.type);
        default:
            // function
            // return obj;
            util_1.util.assertNever(def);
        // break;
    }
    // assertNever();
    // return obj;
}; };
//# sourceMappingURL=parser.js.map